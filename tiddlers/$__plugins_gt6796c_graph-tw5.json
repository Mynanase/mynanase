{
    "tiddlers": {
        "$:/plugins/gt6796c/graph-tw5/example": {
            "title": "$:/plugins/gt6796c/graph-tw5/example",
            "text": "Notation\n\n```\n<$graph color='blue' thickness='1' minX=\"0\" minY=\"-6\" maxY=\"6\" equation=\"\nreturn 5 * Math.sin(x)\n    \">\n</$graph>\n```\nResults\n\n<$graph color='blue' thickness='1' minX=\"0\" minY=\"-6\" maxY=\"6\" equation=\"\n5 * Math.sin(x)\n    \">\n</$graph>\n\nNotation for multiple functions in one graph\n\n```\n<$graph color='[\"red\",\"blue\",\"green\"]' unitsPerTick=\"2\" minX=\"0\" minY=\"-6\" maxY=\"6\">\n5 * Math.sin(x)\n1/x\nx*x+x\n</$graph>\n```\nResults\n\n<$graph color='[\"red\",\"blue\",\"green\"]' unitsPerTick=\"2\" minX=\"0\" minY=\"-6\" maxY=\"6\">\n5 * Math.sin(x)\n1/x\nx*x+x\n</$graph>\n\nNotation for points and point sets in one graph (Note the space between the two opening array brackets. This is to prevent TiddlyWiki from treating it as a Tiddler.)\n\n```\n<$graph color='[\"red\",\"blue\",\"green\"]' minX=\"0\" minY=\"0\">\nx+3\n[2,2]\n[ [3,2],[4,1],[2,5] ]\n</$graph>\n```\nResults\n\n<$graph color='[\"red\",\"blue\",\"green\"]' minX=\"0\" minY=\"0\">\nx+3\n[2,2]\n[ [3,2],[4,1],[2,5] ]\n</$graph>\n\nYou can even do things like limits on your functions like this:\n(Note that the entire clause must not have any newlines in it)\n\n```\n<$graph color='blue' thickness='1' bounds=\"[0,-6,10,6]\" equation=\"\nx < /*lower*/ Math.PI/2 ? undefined : /*upper*/ x > 5*Math.PI/2 ? undefined : /*function*/ 5 * Math.sin(x)\n\">\n</$graph>\n```\n\nResults\n\n<$graph color='blue' thickness='1' bounds=\"[0,-6,10,6]\" equation=\"\nx < /*lower*/ Math.PI/2 ? undefined : /*upper*/ x > 5*Math.PI/2 ? undefined : /*function*/ 5 * Math.sin(x)\n\">\n</$graph>\n"
        },
        "$:/plugins/gt6796c/graph-tw5/graph.js": {
            "text": "/*\\\ntitle: $:/plugins/gt6796c/graph-tw5/graph.js\ntype: application/javascript\nmodule-type: lib\n\n\\*/\n// Based on http://www.html5canvastutorials.com/labs/html5-canvas-graphing-an-equation/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\n\n      function Graph() { }\n\n      Graph.prototype.configure = function(config) {\n        // user defined properties\n        this.canvas = config.canvas;\n        this.minX = config.minX;\n        this.minY = config.minY;\n        this.maxX = config.maxX;\n        this.maxY = config.maxY;\n        this.unitsPerTick = config.unitsPerTick;\n\n        // constants\n        this.axisColor = '#aaa';\n        this.font = '8pt Calibri';\n        this.tickSize = 20;\n\n        // relationships\n        this.context = this.canvas.getContext('2d');\n        this.rangeX = this.maxX - this.minX;\n        this.rangeY = this.maxY - this.minY;\n        this.unitX = this.canvas.width / this.rangeX;\n        this.unitY = this.canvas.height / this.rangeY;\n        this.centerY = Math.round(Math.abs(this.minY / this.rangeY) * this.canvas.height);\n        this.centerX = Math.round(Math.abs(this.minX / this.rangeX) * this.canvas.width);\n        this.iteration = (this.maxX - this.minX) / 1000;\n\n        if (typeof(config.step) != \"undefined\")\n        {\n          // don't let absurd values through\n          var step = parseFloat(config.step);\n          if (step >= this.iteration)\n            this.iteration=step;\n        }\n\n        this.scaleX = this.canvas.width / this.rangeX;\n        this.scaleY = this.canvas.height / this.rangeY;\n\n        // draw x and y axis\n        this.drawXAxis();\n        this.drawYAxis();\n      }\n\n      Graph.prototype.drawXAxis = function() {\n        var context = this.context;\n          var ypos = this.canvas.height - this.centerY;\n        context.save();\n        context.beginPath();\n        context.moveTo(0, ypos);\n        context.lineTo(this.canvas.width, ypos);\n        context.strokeStyle = this.axisColor;\n        context.lineWidth = 2;\n        context.stroke();\n\n        // draw tick marks\n        var xPosIncrement = this.unitsPerTick * this.unitX;\n        var xPos, unit;\n        context.font = this.font;\n        context.textAlign = 'center';\n        context.textBaseline = 'top';\n\n        // draw left tick marks\n        xPos = this.centerX - xPosIncrement;\n        unit = -1 * this.unitsPerTick;\n        while(xPos > 0) {\n          context.moveTo(xPos, ypos - this.tickSize / 2);\n          context.lineTo(xPos, ypos + this.tickSize / 2);\n          context.stroke();\n          context.fillText(unit, xPos, ypos + this.tickSize / 2 + 3);\n          unit -= this.unitsPerTick;\n          xPos = Math.round(xPos - xPosIncrement);\n        }\n\n        // draw right tick marks\n        xPos = this.centerX + xPosIncrement;\n        unit = this.unitsPerTick;\n        while(xPos < this.canvas.width) {\n          context.moveTo(xPos, ypos - this.tickSize / 2);\n          context.lineTo(xPos, ypos + this.tickSize / 2);\n          context.stroke();\n          context.fillText(unit, xPos, ypos + this.tickSize / 2 + 3);\n          unit += this.unitsPerTick;\n          xPos = Math.round(xPos + xPosIncrement);\n        }\n        context.restore();\n      };\n\n      Graph.prototype.drawYAxis = function() {\n        var context = this.context;\n          var ypos = this.canvas.height - this.centerY;\n        context.save();\n        context.beginPath();\n        context.moveTo(this.centerX, 0);\n        context.lineTo(this.centerX, this.canvas.height);\n        context.strokeStyle = this.axisColor;\n        context.lineWidth = 2;\n        context.stroke();\n\n        // draw tick marks\n        var yPosIncrement = this.unitsPerTick * this.unitY;\n        var yPos, unit;\n        context.font = this.font;\n        context.textAlign = 'right';\n        context.textBaseline = 'middle';\n\n        // draw top tick marks\n        yPos = ypos - yPosIncrement;\n        unit = this.unitsPerTick;\n        while(yPos > 0) {\n          context.moveTo(this.centerX - this.tickSize / 2, yPos);\n          context.lineTo(this.centerX + this.tickSize / 2, yPos);\n          context.stroke();\n          context.fillText(unit, this.centerX - this.tickSize / 2 - 3, yPos);\n          unit += this.unitsPerTick;\n          yPos = Math.round(yPos - yPosIncrement);\n        }\n\n        // draw bottom tick marks\n        yPos = ypos + yPosIncrement;\n        unit = -1 * this.unitsPerTick;\n        while(yPos < this.canvas.height) {\n          context.moveTo(this.centerX - this.tickSize / 2, yPos);\n          context.lineTo(this.centerX + this.tickSize / 2, yPos);\n          context.stroke();\n          context.fillText(unit, this.centerX - this.tickSize / 2 - 3, yPos);\n          unit -= this.unitsPerTick;\n          yPos = Math.round(yPos + yPosIncrement);\n        }\n        context.restore();\n      };\n\n      Graph.prototype.drawEquation = function(equation, color, thickness) {\n        var context = this.context;\n        context.save();\n        context.save();\n        this.transformContext();\n\n        context.beginPath();\n        context.moveTo(this.minX, equation(this.minX));\n\n        var result = equation(this.minX.toFixed(4));\n        // see if they've passed an array for points\n        if (result instanceof Array)\n        {\n          // if what they sent is not an array of arrays (multiple points)\n          // go ahead and wrap it so we have one code path\n          var points = result[0] instanceof Array ? result : [result];\n          var w = this.scaleY*this.iteration/3;\n          var z = this.scaleX*this.iteration/3;\n          for (var pi=0;pi<points.length;++pi)\n          {\n            var px = points[pi][0];\n            var py = points[pi][1];\n            context.fillStyle = color;\n            context.fillRect(px-w,py-z,2*w,2*z);\n          }\n\n        }\n        else {\n          for (var x = this.minX + this.iteration; x <= this.maxX; x += this.iteration) {\n            result = equation(x.toFixed(4));\n            if (isFinite(result))\n              context.lineTo(x, equation(x));\n          }\n        }\n\n        context.restore();\n        context.lineJoin = 'round';\n        context.lineWidth = thickness;\n        context.strokeStyle = color;\n        context.stroke();\n        context.restore();\n      };\n\n      Graph.prototype.transformContext = function() {\n        var context = this.context;\n\n        // move context to center of canvas\n        this.context.translate(this.centerX, this.canvas.height - this.centerY);\n\n        /*\n         * stretch grid to fit the canvas window, and\n         * invert the y scale so that that increments\n         * as you move upwards\n         */\n        context.scale(this.scaleX, -this.scaleY);\n      };\n\n    exports.graph = Graph;\n\n})();\n",
            "title": "$:/plugins/gt6796c/graph-tw5/graph.js",
            "type": "application/javascript",
            "module-type": "lib"
        },
        "$:/plugins/gt6796c/graph-tw5/license": {
            "title": "$:/plugins/gt6796c/graph-tw5/license",
            "text": "The MIT License (MIT)\n\nCopyright (c) 2016 Nathaniel Jones\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\nDependencies:\nBased in part on http://www.html5canvastutorials.com/labs/html5-canvas-graphing-an-equation/ No License Found\n"
        },
        "$:/plugins/gt6796c/graph-tw5/readme": {
            "title": "$:/plugins/gt6796c/graph-tw5/readme",
            "text": "This is a TiddlyWiki plugin for creating simple graphs.\n\nIt is completely self-contained, and doesn't need an Internet connection in order to work. It works both in the browser and under Node.js.\n\n\n!Installation\nYou can either build from [[Source code|https://github.com/gt6796c/graph-tw5]] or install from [[here|https://gt6796c.github.io]]\n\n!Dependencies\n;This plugin requires:\n*[[rocklib Plugin|https://gt6796c.github.io]]\n\n! History\n;0.1.2\n*Fixed single color attributes and fixed example to use //color// instead of //colors//"
        },
        "$:/plugins/gt6796c/graph-tw5/typed-parser.js": {
            "text": "/*\\\ntitle: $:/plugins/gt6796c/graph-tw5/typed-parser.js\ntype: application/javascript\nmodule-type: parser\n\nThis parser wraps unadorned railroad syntax into a railroad widget\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\n\tvar GraphParser = function(type,text,options) {\n\t\tvar element = {\n\t\t\ttype: \"graph\",\n\t\t\ttag: \"$graph\",\n\t\t\ttext: text\n\t\t};\n\t\tthis.tree = [element];\n\t};\n\n\texports[\"text/vnd.tiddlywiki.graph\"] = GraphParser;\n\n})();\n\n",
            "title": "$:/plugins/gt6796c/graph-tw5/typed-parser.js",
            "type": "application/javascript",
            "module-type": "parser"
        },
        "$:/plugins/gt6796c/graph-tw5/usage": {
            "title": "$:/plugins/gt6796c/graph-tw5/usage",
            "text": "This widget allows the user to create simple graphs and display them in a tiddler. The equation will be provided an 'x' value\nand should return the 'y' value. Multiple Equations can be specified on separate lines to represent a system of equations. Points can\nbe represented by defining the point's coordinates in the form of an array. Arrays can be nested to allow for multiple points\nto be the same color. (See examples)\n\nThe equation body can either be placed in the \"equation\" attribute or as the body of the widget.\n\nThe following attributes are customizable for the widget:\n\n; minX - integer\n: defaults to -1\n; minY - integer\n: defaults to -1\n; maxX - integer\n: defaults to 10\n; maxY - integer\n: default to 10\n; width - integer\n: defaults to \"not specified\"\n; height - integer\n: defaults to \"not specified\"\n; color - string\n: defaults to 'red'\n;thickness - integer\n: defaults to 2\n; unitsPerTick\n: defaults to 1\n; bounds - integer array\n: no default 2 elements sets the minX & minY. 4 elements sets minX, minY, maxX and maxY\n; step - float\n: defaults to '0.001'\n\nThe following attributes are for systems of equations:\n\n;color - json array of colors e.g. ['red','green','blue']\n: defaults to using value of 'color' attribute defined above\n;thickness - json array of integers e.g. [2,2,1]\n: defaults to using value of 'thickness' attribute defined above\n\nNote the number of colors & thicknesses should match the number of equations specified. If there are more equations specified, random colors will\nbe assigned.\n\n!!Notes\n*The body of the text is parsed as a Tiddler. If you need conflicting elements, use either the ``equation`` attribute on the widget or set the type field to ``text/vnd.tiddlywiki.graph`` and transclude the whole Tiddler\n** In particular, the Javascript array of array syntax will be parsed as a Tiddler Title unless you leave an empty space between the two opening brackets.\n* If you author a Tiddler with the Content type ``text/vnd.tiddlywiki.graph`` CamelCased variables may be assigned by using a 'dot' notation. (e.g. minX would be graph-min.x)\n"
        },
        "$:/plugins/gt6796c/graph-tw5/widget.js": {
            "text": "/*\\\ntitle: $:/plugins/gt6796c/graph-tw5/widget.js\ntype: application/javascript\nmodule-type: widget\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\n    var Widget = require(\"$:/core/modules/widgets/widget.js\").widget;\n    var Rocklib = require(\"$:/plugins/gt6796c/rocklib/widget-tools.js\").rocklib;\n    var Graph = require(\"./graph.js\").graph;\n\n    if ($tw.browser) {\n        window.graph = new Graph();\n        window.rocklib = new Rocklib();\n    }\n\n\n    var GraphWidget = function(parseTreeNode, options) {\n        this.initialise(parseTreeNode, options);\n    };\n\n    GraphWidget.prototype = new Widget();\n\n    /*\n     Render this widget into the DOM\n     */\n    GraphWidget.prototype.render = function(parent,nextSibling) {\n        this.parentDomNode = parent;\n        this.computeAttributes();\n        this.execute();\n\n        var tag = 'graph';\n        var scriptBody = rocklib.getScriptBody(this,\"equation\").trim();\n        var canvas = rocklib.getCanvas(this,tag,\"canvas\");\n        try {\n            var options = {}\n            options.minX = -1;\n            options.minY = -1;\n            options.maxX = 10;\n            options.maxY = 10;\n            options.color = '#000';\n            options.thickness = 2;\n            options.unitsPerTick = 1;\n\n            rocklib.getOptions(this, tag, options);\n            if (options.hasOwnProperty('bounds'))\n            {\n                var bounds = options['bounds']\n                if (bounds.length == 2 || bounds.length == 4)\n                {\n                    options.minX = bounds[0];\n                    options.minY = bounds[1];\n                    if (bounds.length == 4)\n                    {\n                        options.maxX = bounds[2];\n                        options.maxY = bounds[3];\n                    }\n                }\n            }\n            // swap mins/maxes if they're messed up\n            if (options.minY > options.maxY)\n            {\n                var s = options.maxY;\n                options.maxY = options.minY;\n                options.minY = s;\n            }\n            if (options.minX > options.maxX)\n            {\n                var s = options.maxX;\n                options.maxX = options.minX;\n                options.minX = s;\n            }\n            rocklib.hue = 0;\n            options.canvas = canvas;\n            graph.configure(options);\n            var eqs = scriptBody.split('\\n');\n            for (var i=0;i<eqs.length;++i) {\n                var eq = eqs[i].trim();\n                var f = Function('x', \"return \" + eq + \";\");\n                var c = options.color;\n                var needColor = options.color instanceof Array && i >= options.color.length;\n                needColor |= typeof(options.color) == \"string\" && i > 0;\n                if (needColor)\n                {\n                    c = rocklib.nextColor(.75, 0.95);\n                }\n                else\n                {\n                    c = typeof(options.color) == \"string\" ? options.color : options.color[i];\n                }\n                var t = typeof(options.thicknesses) != \"undefined\" && i < options.thicknesses.length ? options.thicknesses[i] : options.thickness;\n                graph.drawEquation(f, c, t);\n            }\n        }\n        catch(ex)\n        {\n            canvas = this.document.createElement(\"div\");\n            canvas.innerText = ex.stack;\n        }\n        parent.insertBefore(canvas, nextSibling);\n\n        this.domNodes.push(canvas);\n    };\n\n    GraphWidget.prototype.execute = function() {\n        // Nothing to do\n    };\n\n    /*\n     Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\n     */\n    GraphWidget.prototype.refresh = function(changedTiddlers) {\n        return false;\n    };\n\n    exports.graph = GraphWidget;\n\n})();\n",
            "title": "$:/plugins/gt6796c/graph-tw5/widget.js",
            "type": "application/javascript",
            "module-type": "widget"
        }
    }
}